/*******************************************************************************
 * Copyright (c) 2014-2016 European Molecular Biology Laboratory,
 * Heidelberg, Germany.
 * 
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of
 * the License at
 * 
 *  		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, 
 * software distributed under the License is distributed on 
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 * KIND, either express or implied. See the License for the 
 * specific language governing permissions and limitations 
 * under the License.
 ******************************************************************************/
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.7 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.03.24 at 03:18:36 PM GMT 
//


package eu.ddmore.libpharmml.dom.commontypes;

import java.util.ArrayList;
import java.util.List;

import javax.swing.tree.TreeNode;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlType;

import eu.ddmore.libpharmml.dom.maths.ExpressionValue;
import eu.ddmore.libpharmml.MathExpressionConverter;
import eu.ddmore.libpharmml.dom.tags.LogicBinOperand;
import eu.ddmore.libpharmml.dom.tags.MathExpression;
import eu.ddmore.libpharmml.impl.MathExpressionConverterToExpression;
import eu.ddmore.libpharmml.impl.MathExpressionConverterToMathML;
import eu.ddmore.libpharmml.impl.XMLFilter;
import eu.ddmore.libpharmml.util.ChainedList;


/**
 * The definition of a non-uniform sequence of numbers. The vector is an ordered list of
 *             values. The values of the sequence element are inserted into the vector at the point of definition.
 *             For example, take the vector (the [] brackets denote a sequence): 0, 4, [0:1:3], 33. Inserting the 
 *             sequence gives us the vector of values: 0, 4, 0, 1, 2, 3, 33. 
 *             
 * <p>Vectors can have 2 different forms. A first one where all the elements of the vector are specified (Type A),
 * and an other one where the elements that are not explicitly specified have a default value (Type B).
 * The possible values in a vector are {@link Scalar}, {@link SymbolRef} and {@link Sequence}.
 * 
 * <p><h3>Type A (complete):</h3>
 * This is the most simple representation of a vector.
 * All the elements within the vector have to be explicitly specified. These elements are wrapped
 * into a {@link VectorElements} object within the vector. In this case, the {@link VectorElements}
 * object is the only child element authorized in the {@link Vector}.
 * <p>For example, if one wants to encode a vector with the following values:
 * <p>{0,0,1,5,6,4,2,0}
 * <p>then one can proceed as follows:
 * <p><code>
 * Integer[] values = {0,0,1,5,6,4,2,0};<br>
 * Vector vector = new Vector();<br>
 * VectorElements vectorElements = vector.createVectorElements();<br>
 * for(Integer value : values){<br>
 * &nbsp;&nbsp;&nbsp;vectorElements.createIntValue(value);<br>
 * }<br>
 * vector.setLength(values.length);<br>
 * </code>
 * <p>It is mandatory to specify manually the length of the vector. This is because the length
 * of the vector cannot be found automatically when a {@link Sequence} or a {@link SymbolRef}
 * object is in the list, as it can refer to multiple values.
 * 
 * <p><h3>Type B (sparse):</h3>
 * It is possible to specify only a few elements within the vector. The value of the other ones equals
 * the default value of the vector. In this form, the "default" attribute is mandatory.   
 * To specify some values, one can include {@link VectorCell} elements or {@link VectorSegment} elements. 
 * 
 * <p>Example:
 * <p>Vector to encode: {0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0}
 * <p><code>
 * Vector vector = new Vector();<br>
 * vector.setDefaultValue(0);<br>
 * vector.setLength(16);<br>
 * vector.createVectorCell(4,1); // index, value<br>
 * vector.createVectorSegment(8,5,1); // startIndex, length, defaultValue<br>
 * </code>
 * 
 * <p><h3>Schema:</h3>
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="VectorType">
 *   &lt;complexContent>
 *     &lt;extension base="{http://www.pharmml.org/pharmml/0.8/CommonTypes}PharmMLRootType">
 *       &lt;choice minOccurs="0">
 *         &lt;element name="VectorElements" type="{http://www.pharmml.org/pharmml/0.8/CommonTypes}VectorElementsType"/>
 *         &lt;choice maxOccurs="unbounded">
 *           &lt;element name="VectorCell" type="{http://www.pharmml.org/pharmml/0.8/CommonTypes}VectorCellType" maxOccurs="unbounded"/>
 *           &lt;element name="VectorSegment" type="{http://www.pharmml.org/pharmml/0.8/CommonTypes}VectorSegmentType" maxOccurs="unbounded"/>
 *         &lt;/choice>
 *       &lt;/choice>
 *       &lt;attribute name="length" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="default" type="{http://www.w3.org/2001/XMLSchema}double" default="0" />
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "VectorType", propOrder = {
	"vectorElements",
	"vectorCellOrVectorSegment",
    "sequenceOrScalar"
})
public class Vector extends AbstractVector implements ExpressionValue, MathExpression, LogicBinOperand {
	
	// deprecated since 0.3.2
	@XmlElementRefs({
		@XmlElementRef(name = "Sequence", namespace = XMLFilter.NS_DEFAULT_CT, type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Scalar", namespace = XMLFilter.NS_DEFAULT_CT, type = JAXBElement.class, required = false)
	})
	protected List<JAXBElement<?>> sequenceOrScalar;
	// ----------
    
    @XmlElements({
        @XmlElement(name = "VectorCell", type = VectorCell.class),
        @XmlElement(name = "VectorSegment", type = VectorSegment.class)
    })
    protected List<PharmMLRootType> vectorCellOrVectorSegment;
        
    @XmlAttribute(name = "length")
    protected Integer length;
    
    /**
	 * Creates an empty vector.
	 */
	public Vector(){
	}
	
	/**
	 * Constructs a type-A vector from provided values.
	 * @param values An array of {@link VectorValue} elements.
	 * @param length Length of the vector.
	 */
	public Vector(VectorValue []values, int length){
		this.vectorElements = new VectorElements(values);
		this.length = length;
	}
	
	/**
	 * Constructs a type-B vector with a default value. This type of vector is meant to be filled
	 * by {@link VectorCell} elements or {@link VectorSegment} elements.
	 * @param defaultValue The value of the vector cells that are not explicitly specified.
	 * @param length Length of the vector.
	 */
	public Vector(double defaultValue,int length){
		this.defaultValue = defaultValue;
		this.length = length;
	}
	
	public boolean addVectorCell(VectorCell cell){
		return getListOfVectorCellAndSegment().add(cell);
	}
	
	public boolean addVectorSegment(VectorSegment segment) {
		return getListOfVectorCellAndSegment().add(segment);
	}
    
    /**
     * Gets the value of the sequenceOrScalar property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sequenceOrScalar property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSequenceOrScalar().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link IdValue }{@code >}
     * {@link JAXBElement }{@code <}{@link FalseBoolean }{@code >}
     * {@link JAXBElement }{@code <}{@link Sequence }{@code >}
     * {@link JAXBElement }{@code <}{@link StringValue }{@code >}
     * {@link JAXBElement }{@code <}{@link IntValue }{@code >}
     * {@link JAXBElement }{@code <}{@link Object }{@code >}
     * {@link JAXBElement }{@code <}{@link RealValue }{@code >}
     * {@link JAXBElement }{@code <}{@link BooleanValue }{@code >}
     * {@link JAXBElement }{@code <}{@link TrueBoolean }{@code >}
     * 
     * 
     */
    @Deprecated
    public List<JAXBElement<?>> getSequenceOrScalar() {
        if (sequenceOrScalar == null) {
            sequenceOrScalar = new ArrayList<JAXBElement<?>>();
        }
        return this.sequenceOrScalar;
    }
    
   
    public List<PharmMLRootType> getListOfVectorCellAndSegment(){
    	if(vectorCellOrVectorSegment == null){
    		vectorCellOrVectorSegment = new ArrayList<PharmMLRootType>();
    	}
    	return vectorCellOrVectorSegment;
    }
    
    public Integer getLength(){
    	return this.length;
    }
    
    public void setLength(int length){
    	this.length = length;
    }
    
    /**
	 * Creates a new vector cell into the vector at the specified index without any value.
	 * @param index Index of the cell within the vector.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index){
		VectorCell cell = new VectorCell();
		cell.setVectorIndex(new MatrixVectorIndex(index));
		addVectorCell(cell);
		return cell;
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a symbol as value.
	 * @param index Index of the cell within the vector.
	 * @param value Symbol value of the cell.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index, SymbolRef value){
		VectorCell cell = createVectorCell(index);
		cell.setValue(value);
		return cell;
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a scalar as value.
	 * @param index Index of the cell within the vector.
	 * @param value {@link Scalar} value of the cell.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index, Scalar value){
		VectorCell cell = createVectorCell(index);
		cell.setValue(value);
		return cell;
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a real value.
	 * A {@link RealValue} object is constructed from the provided primitive variable.
	 * @param index Index of the cell within the vector.
	 * @param value Primitive value of the cell.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index, double value){
		return createVectorCell(index, new RealValue(value));
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a integer value.
	 * A {@link IntValue} object is constructed from the provided primitive variable.
	 * @param index Index of the cell within the vector.
	 * @param value Primitive value of the cell.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index, int value){
		return createVectorCell(index, new IntValue(value));
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a boolean value.
	 * A {@link BooleanValue} object is constructed from the provided primitive variable.
	 * @param index Index of the cell within the vector.
	 * @param value Primitive value of the cell.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index, boolean value){
		return createVectorCell(index, BooleanValue.fromBoolean(value));
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a string value.
	 * A {@link StringValue} object is constructed from the provided primitive variable.
	 * @param index Index of the cell within the vector.
	 * @param value Primitive value of the cell.
	 * @return The created {@link VectorCell} instance.
	 */
	public VectorCell createVectorCell(int index, String value){
		return createVectorCell(index, new StringValue(value));
	}
	
	/**
	 * Creates a new vector cell into the vector at the specified index with a value.
	 * This is the most abstracted method for creating a cell.
	 * @param index The index of the cell as {@link MatrixVectorIndex}
	 * @param value The value of the cell which can be {@link Scalar} or {@link SymbolRef}
	 * @return The created cell.
	 */
	public VectorCell createVectorCell(MatrixVectorIndex index, VectorCellValue value){
		VectorCell cell = new VectorCell();
		if(value instanceof Scalar){
			cell.setValue((Scalar) value);
		} else if(value instanceof SymbolRef){
			cell.setValue((SymbolRef) value);
		}
		cell.setVectorIndex(index);
		addVectorCell(cell);
		return cell;
	}
	
	/**
	 * Creates an empty vector segment into the vector and returns it.
	 * @return The created {@link VectorSegment} object.
	 */
	public VectorSegment createVectorSegment(){
		VectorSegment segment = new VectorSegment();
		addVectorSegment(segment);
		return segment;
	}
	
	/**
	 * Creates a vector segment into the vector and returns it. 
	 * @param startIndex Start index of the segment within the parent vector.
	 * @param segmentLength Length of the segment.
	 * @param defaultValue Value of the vector elements that are explictly specified.
	 * @param values Values of the segment.
	 * @return The created {@link VectorSegment} object.
	 */
	public VectorSegment createVectorSegment(int startIndex, int segmentLength, double defaultValue, VectorValue values[]){
		VectorSegment segment = new VectorSegment(
				new MatrixVectorIndex(startIndex), 
				new MatrixVectorIndex(segmentLength), 
				defaultValue, 
				values);
		addVectorSegment(segment);
		return segment;
	}
	
	/**
	 * Creates a vector segment into the vector and returns it. 
	 * @param startIndex Start index of the segment within the parent vector.
	 * @param segmentLength Length of the segment.
	 * @param defaultValue Value of the vector elements that are explictly specified.
	 * @return The created {@link VectorSegment} object.
	 */
	public VectorSegment createVectorSegment(int startIndex, int segmentLength, double defaultValue){
		VectorSegment segment = new VectorSegment(
				new MatrixVectorIndex(startIndex), 
				new MatrixVectorIndex(segmentLength), 
				defaultValue);
		addVectorSegment(segment);
		return segment;
	}

	@Override
	protected List<TreeNode> listChildren() {
		List<TreeNode> list = new ChainedList<TreeNode>()
				.addIfNotNull(vectorElements)
				.addIfNotNull(vectorCellOrVectorSegment);
		if(sequenceOrScalar != null){
			for(JAXBElement<?> jaxbEl : sequenceOrScalar){
				if(jaxbEl.getValue() instanceof TreeNode){
					list.add((TreeNode) jaxbEl.getValue());
				}
			}
		}
		return list;
	}

	@Override
	public String toMathExpression() {
		return new MathExpressionConverterToExpression().convert(this);
	}

	@Override
	public String toMathML() {
		return new MathExpressionConverterToMathML().convert(this);
	}

	@Override
	public String convert(MathExpressionConverter converter) {
		return converter.convert(this);
	}

	@Override
	public JAXBElement<Vector> toJAXBElement() {
		return ObjectFactory.getInstance().createVector(this);
	}

	@Override
	public JAXBElement<Vector> toJAXBElementOfLogicBinOp() {
		return ObjectFactory.getInstance().createVector(this);
	}
    

}
