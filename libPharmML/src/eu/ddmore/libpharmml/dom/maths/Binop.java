/*******************************************************************************
 * Copyright (c) 2014 European Molecular Biology Laboratory,
 * Heidelberg, Germany.
 *
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of
 * the License at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, 
 * software distributed under the License is distributed on 
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 * KIND, either express or implied. See the License for the 
 * specific language governing permissions and limitations 
 * under the License.
 *******************************************************************************/
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.7 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.03.24 at 03:18:36 PM GMT 
//


package eu.ddmore.libpharmml.dom.maths;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import eu.ddmore.libpharmml.dom.MasterObjectFactory;
import eu.ddmore.libpharmml.dom.commontypes.PharmMLRootType;
import eu.ddmore.libpharmml.impl.LoggerWrapper;


/**
 * 
 * A binary operator describing a numerical operation. Takes two operands (as you would expect).
 *             
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="BinopType">
 *   &lt;complexContent>
 *     &lt;extension base="{http://www.pharmml.org/2013/03/CommonTypes}PharmMLRootType">
 *       &lt;sequence>
 *         &lt;choice>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Scalar"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}SymbRef"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/08/Dataset}ColumnRef"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}Constant"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}Binop"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}Uniop"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}FunctionCall"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Sum"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Product"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Delay"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}VectorSelector"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}MatrixSelector"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/ModelDefinition}Probability"/>
 *         &lt;/choice>
 *         &lt;choice>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Scalar"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}SymbRef"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/08/Dataset}ColumnRef"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}Constant"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}Binop"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}Uniop"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/Maths}FunctionCall"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Sum"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Product"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}Delay"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}VectorSelector"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/CommonTypes}MatrixSelector"/>
 *           &lt;element ref="{http://www.pharmml.org/2013/03/ModelDefinition}Probability"/>
 *         &lt;/choice>
 *       &lt;/sequence>
 *       &lt;attribute name="op" use="required">
 *         &lt;simpleType>
 *           &lt;restriction base="{http://www.w3.org/2001/XMLSchema}Name">
 *             &lt;enumeration value="plus"/>
 *             &lt;enumeration value="minus"/>
 *             &lt;enumeration value="times"/>
 *             &lt;enumeration value="divide"/>
 *             &lt;enumeration value="power"/>
 *             &lt;enumeration value="logx"/>
 *             &lt;enumeration value="root"/>
 *             &lt;enumeration value="min"/>
 *             &lt;enumeration value="max"/>
 *             &lt;enumeration value="rem"/>
 *           &lt;/restriction>
 *         &lt;/simpleType>
 *       &lt;/attribute>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "BinopType", propOrder = {
    "content"
})
public class Binop
    extends PharmMLRootType implements Operand
{
    
	@XmlElementRefs({
        @XmlElementRef(name = "Sum", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false),
		@XmlElementRef(name = "ColumnRef", namespace = "http://www.pharmml.org/2013/08/Dataset", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Uniop", namespace = "http://www.pharmml.org/2013/03/Maths", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "MatrixSelector", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Scalar", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "FunctionCall", namespace = "http://www.pharmml.org/2013/03/Maths", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Constant", namespace = "http://www.pharmml.org/2013/03/Maths", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Delay", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "VectorSelector", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Binop", namespace = "http://www.pharmml.org/2013/03/Maths", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Probability", namespace = "http://www.pharmml.org/2013/03/ModelDefinition", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "Product", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "SymbRef", namespace = "http://www.pharmml.org/2013/03/CommonTypes", type = JAXBElement.class, required = false)
    })
    protected List<JAXBElement<?>> content;
    @XmlAttribute(name = "op", required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    protected String op;
    
    @XmlTransient
    protected Operand operand1;
    @XmlTransient
    protected Operand operand2;
    @XmlTransient
    protected Binoperator operator;
    
    /**
     * Empty constructor.
     */
    public Binop(){
    	init();
    }
    
    /**
     * Creates a new binop element with the provided operands and operator.
     * @param operator
     * @param operand1
     * @param operand2
     */
    public Binop(Binoperator operator, Operand operand1, Operand operand2){
    	this();
    	this.operator = operator;
    	this.operand1 = operand1;
    	this.operand2 = operand2;
    }

    /**
     * Clears the mapped attributes before setting their values for marshalling.
     */
    private void init(){
    	content = new ArrayList<JAXBElement<?>>();
    	content.add(null);
    	content.add(null);
    	op = null;
    }
    
    /**
     * Gets the operator value of the binop.
     * @return The operator as {@link Binoperator} enum.
     */
    public Binoperator getOperator(){
    	return operator;
    }
    
    /**
     * Sets the operator of the binop.
     * @param operator 
     */
    public void setOperator(Binoperator operator){
    	this.operator = operator;
    }
    
    /**
     * Gets the 1st operand.
     * @return Possible return types are:
     *   {@link Delay},
     *   {@link MatrixSelector},
     *   {@link Product},
     *   {@link Scalar},
     *   {@link Sum},
     *   {@link SymbolRef},
     *   {@link VectorSelector},
     *   {@link ColumnRef},
     *   {@link Binop},
     *   {@link Constant},
     *   {@link FunctionCall},
     *   {@link Uniop},
     *   {@link Probability}
     */
    public Operand getOperand1(){
    	return operand1;
    }
    
    /**
     * Gets the 2nd operand.
     * @return Possible return types are:
     *   {@link Delay},
     *   {@link MatrixSelector},
     *   {@link Product},
     *   {@link Scalar},
     *   {@link Sum},
     *   {@link SymbolRef},
     *   {@link VectorSelector},
     *   {@link ColumnRef},
     *   {@link Binop},
     *   {@link Constant},
     *   {@link FunctionCall},
     *   {@link Uniop},
     *   {@link Probability}
     */
    public Operand getOperand2(){
    	return operand2;
    }
    
    /**
     * Sets the 1st operand.
     * Possible types are:
     *   {@link Delay},
     *   {@link MatrixSelector},
     *   {@link Product},
     *   {@link Scalar},
     *   {@link Sum},
     *   {@link SymbolRef},
     *   {@link VectorSelector},
     *   {@link ColumnRef},
     *   {@link Binop},
     *   {@link Constant},
     *   {@link FunctionCall},
     *   {@link Uniop},
     *   {@link Probability}
     */
    public void setOperand1(Operand operand){
    	this.operand1 = operand;
    }
    
    /**
     * Sets the 2nd operand.
     * Possible types are:
     *   {@link Delay},
     *   {@link MatrixSelector},
     *   {@link Product},
     *   {@link Scalar},
     *   {@link Sum},
     *   {@link SymbolRef},
     *   {@link VectorSelector},
     *   {@link ColumnRef},
     *   {@link Binop},
     *   {@link Constant},
     *   {@link FunctionCall},
     *   {@link Uniop},
     *   {@link Probability}
     */
    public void setOperand2(Operand operand){
    	this.operand2 = operand;
    }
    
    public <T extends Operand> T createOperand1(T operand1){
    	setOperand1(operand1);
    	return operand1;
    }

	@Override
	public JAXBElement<Binop> toJAXBElement() {
		return MasterObjectFactory.MATHS_OF.createBinop(this);
	}
	
	protected void beforeMarshal(Marshaller m){
		init();
		if(operand1 != null){
			content.set(0, operand1.toJAXBElement());
		}
		if(operand2 != null){
			content.set(1, operand2.toJAXBElement());
		}
		if(operator != null){
			op = operator.getOperator();
		}
	}
	
	protected void afterUnmarshal(Unmarshaller u, Object parent) {
		  if(content != null){
			  if(content.size() >= 1){
				  Object _operand = content.get(0).getValue();
				  if(_operand instanceof Operand){
					  operand1 = (Operand) _operand;
				  } else {
					  LoggerWrapper.getLogger().warning(_operand+" is not unmarshalled as it is not an Operand type.");
				  }
			  }
			  if(content.size() >= 2){
				  Object _operand = content.get(1).getValue();
				  if(_operand instanceof Operand){
					  operand2 = (Operand) _operand;
				  } else {
					  LoggerWrapper.getLogger().warning(_operand+" is not unmarshalled as it is not an Operand type.");
				  }
			  }
		  }
		  if(op != null){
			  operator = Binoperator.fromString(op);
		  }
	}

}
